#!/usr/bin/env bash
#
# git-update ‚Äî mise √† jour compl√®te d‚Äôun d√©p√¥t Git local
#

die() {
  echo >&2 "Erreur¬†: $*"
  exit 1
}

git rev-parse --is-inside-work-tree &>/dev/null || die "Pas dans un d√©p√¥t Git¬†!"

# 1Ô∏è‚É£ V√©rification des changements locaux
output=$(git status --porcelain)
if [ -n "$output" ]; then
  echo "üõ†Ô∏è  Changements locaux d√©tect√©s (non index√©s, index√©s ou non suivis)¬†:"
  git status -s
  read -p "Voulez-vous faire 'git add -A' + commit + push ? [Y/n] " REPLY
  REPLY=${REPLY:-Y}
  if [[ $REPLY =~ ^[Yy] ]]; then
    git add -A
    read -p "Message de commit¬†: " MSG
    MSG=${MSG:-"Mise √† jour locale automatique"}
    git commit -m "$MSG" || die "Le commit a √©chou√©."
    git push || die "Le push a √©chou√©."
  else
    echo "Op√©ration annul√©e. Pense √† commit/push manuellement."
  fi
fi

# 2Ô∏è‚É£ Synchronisation distante
echo "‚Üí R√©cup√©ration des infos distantes..."
git fetch --prune || die "√âchec du fetch."

LOCAL=$(git rev-parse @) || die
REMOTE=$(git rev-parse @{u}) || die "Branche distante non suivie."
BASE=$(git merge-base @ @{u}) || die

if [ "$LOCAL" = "$REMOTE" ]; then
  echo "‚úÖ La branche est √† jour avec le serveur."
elif [ "$LOCAL" = "$BASE" ]; then
  echo "‚¨áÔ∏è  Des changements distants sont disponibles."
  read -p "Faire git pull ? [Y/n] " REPLY
  REPLY=${REPLY:-Y}
  if [[ $REPLY =~ ^[Yy] ]]; then
    git pull --rebase || die "Le pull a √©chou√©."
  fi
elif [ "$REMOTE" = "$BASE" ]; then
  echo "‚¨ÜÔ∏è  Vous avez des commits locaux non pouss√©s."
  read -p "Faire git push maintenant ? [Y/n] " REPLY
  REPLY=${REPLY:-Y}
  if [[ $REPLY =~ ^[Yy] ]]; then
    git push || die "Le push a √©chou√©."
  fi
else
  echo "‚ö†Ô∏è  Divergence d√©tect√©e (commits locaux ET distants)."
  echo "Gestion manuelle recommand√©e (merge ou rebase)."
  exit 1
fi

echo "üßπ Prune des branches distantes supprim√©es..."
git remote prune origin

